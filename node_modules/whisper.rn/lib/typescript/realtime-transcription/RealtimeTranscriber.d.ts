import type { VadOptions } from '../index';
import type { RealtimeOptions, RealtimeTranscribeEvent, RealtimeTranscriberCallbacks, RealtimeTranscriberDependencies, AudioSliceNoData } from './types';
/**
 * RealtimeTranscriber provides real-time audio transcription with VAD support.
 *
 * Features:
 * - Automatic slice management based on duration
 * - VAD-based speech detection and auto-slicing
 * - Configurable auto-slice mechanism that triggers on speech_end/silence events
 * - Memory management for audio slices
 * - Queue-based transcription processing
 */
export declare class RealtimeTranscriber {
    private whisperContext;
    private vadContext?;
    private audioStream;
    private fs?;
    private sliceManager;
    private callbacks;
    private options;
    private isActive;
    private isTranscribing;
    private vadEnabled;
    private transcriptionQueue;
    private accumulatedData;
    private wavFileWriter;
    private lastSpeechDetectedTime;
    private lastVadState;
    private lastStatsSnapshot;
    private transcriptionResults;
    private vadEvents;
    constructor(dependencies: RealtimeTranscriberDependencies, options?: RealtimeOptions, callbacks?: RealtimeTranscriberCallbacks);
    /**
     * Start realtime transcription
     */
    start(): Promise<void>;
    /**
     * Stop realtime transcription
     */
    stop(): Promise<void>;
    /**
     * Handle incoming audio data from audio stream
     */
    private handleAudioData;
    /**
     * Accumulate audio data for slice management
     */
    private accumulateAudioData;
    /**
     * Process accumulated audio data through SliceManager
     */
    private processAccumulatedDataForSliceManagement;
    /**
     * Check if auto-slice should be triggered based on VAD event and timing
     */
    private checkAutoSlice;
    /**
     * Process VAD for a completed slice
     */
    private processSliceVAD;
    /**
     * Queue a slice for transcription
     */
    private queueSliceForTranscription;
    /**
     * Detect speech using VAD context
     */
    private detectSpeech;
    private isProcessingTranscriptionQueue;
    /**
     * Process the transcription queue
     */
    private processTranscriptionQueue;
    /**
     * Build prompt from initial prompt and previous slices
     */
    private buildPrompt;
    /**
     * Process a single transcription
     */
    private processTranscription;
    /**
     * Handle audio status changes
     */
    private handleAudioStatusChange;
    /**
     * Handle errors from components
     */
    private handleError;
    /**
     * Update callbacks
     */
    updateCallbacks(callbacks: Partial<RealtimeTranscriberCallbacks>): void;
    /**
     * Update VAD options dynamically
     */
    updateVadOptions(options: Partial<VadOptions>): void;
    /**
     * Update auto-slice options dynamically
     */
    updateAutoSliceOptions(options: {
        autoSliceOnSpeechEnd?: boolean;
        autoSliceThreshold?: number;
    }): void;
    /**
     * Get current statistics
     */
    getStatistics(): {
        isActive: boolean;
        isTranscribing: boolean;
        vadEnabled: boolean;
        audioStats: {
            isRecording: boolean;
            accumulatedSamples: number;
        };
        vadStats: {
            enabled: boolean;
            contextAvailable: boolean;
            lastSpeechDetectedTime: number;
        } | null;
        sliceStats: {
            currentSliceIndex: number;
            transcribeSliceIndex: number;
            totalSlices: number;
            memoryUsage: import("./types").MemoryUsage;
        };
        autoSliceConfig: {
            enabled: boolean;
            threshold: number;
            targetDuration: number;
            minDuration: number;
        };
    };
    /**
     * Get all transcription results
     */
    getTranscriptionResults(): Array<{
        slice: AudioSliceNoData;
        transcribeEvent: RealtimeTranscribeEvent;
    }>;
    /**
     * Force move to the next slice, finalizing the current one regardless of capacity
     */
    nextSlice(): Promise<void>;
    /**
     * Reset all components
     */
    reset(): void;
    /**
     * Release all resources
     */
    release(): Promise<void>;
    /**
     * Emit stats update event if stats have changed significantly
     */
    private emitStatsUpdate;
    /**
     * Determine if stats update should be emitted
     */
    private static shouldEmitStatsUpdate;
    /**
     * Logger function
     */
    private log;
}
//# sourceMappingURL=RealtimeTranscriber.d.ts.map